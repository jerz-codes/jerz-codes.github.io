<!DOCTYPE html>
<html lang="pl-pl">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Zajęcia 18: Wordle, cz. 1 – przygotowania | jerz.codes</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@400;700&display=swap">
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">🏠</a></li>
      
      <li><a href="/zapisy/">Zapisy</a></li>
      
      <li><a href="/faq/">FAQ</a></li>
      
      <li><a href="/kontakt/">Kontakt</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Zajęcia 18: Wordle, cz. 1 – przygotowania</span></h1>

<h2 class="date">2023/03/21</h2>
</div>

<main>
<div>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#obsługa-plików">Obsługa plików</a></li>
    <li><a href="#czy-funkcja-jest-obiektem">Czy funkcja jest obiektem?</a>
      <ul>
        <li><a href="#powtórka-z-typów-danych">Powtórka z typów danych</a></li>
        <li><a href="#funkcja-w-stałej">Funkcja w stałej</a></li>
        <li><a href="#typ-funkcji">Typ funkcji</a></li>
        <li><a href="#funkcja-jako-parametr">Funkcja jako parametr</a></li>
        <li><a href="#anonimowe-funkcje-i-wyrażenia-lambda">Anonimowe funkcje i wyrażenia lambda</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div>
<hr>
<p>Następnym dużym programem, który napiszemy, będzie klon gry Wordle:</p>
<p><img src="wordle-original.png" alt=""></p>
<p>Zapewne zajmie nam to kilka zajęć. Musimy przygotować słownik haseł oraz listę dopuszczalnych słów i dobrze byłoby przechowywać je w osobnym pliku, a nie w kodzie programu. Czyli musimy nauczyć się jak wczytywać dane z plików.</p>
<p>Będziemy przeprowadzać sporo operacji na kolekcjach danych (tj. <code>List</code>ach i <code>Map</code>ach), więc chciałbym wam też pokazać lepszy sposób pracy z nimi. A żeby zrozumieć, jak to wszystko działa i łączy się ze sobą, musimy znów chwilkę porozmawiać o funkcjach i obiektach.</p>
<p>Na koniec poznamy też inne tryby naszego terminala, żeby nasza gra miała sympatyczniejszy interfejs użytkownika.</p>
<p>Tak więc najbliższe zajęcia będą wyglądały trochę w ten sposób:</p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/AbSehcT19u0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<h1 id="obsługa-plików">Obsługa plików</h1>
<p>Na dobry początek, stwórzcie nowy program w pakiecie <code>jerz.codes.gry.wordle</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">package</span> jerz.codes.gry.wordle
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> jerz.codes.terminal.terminal
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>() = terminal {
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Następnie, korzystając z panelu <code>Project</code> w IntelliJ, dodajcie w tym samym katalogu nowy plik o nazwie <code>slownik.txt</code>, a potem dodajcie do niego kilkanaście wyrazów, np.:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>TOOTH
</span></span><span style="display:flex;"><span>BOOTH
</span></span><span style="display:flex;"><span>RADIO
</span></span><span style="display:flex;"><span>RUDDY
</span></span><span style="display:flex;"><span>TORCH
</span></span><span style="display:flex;"><span>DREAM
</span></span><span style="display:flex;"><span>DEATH
</span></span><span style="display:flex;"><span>DESIRE
</span></span><span style="display:flex;"><span>DESPAIR
</span></span><span style="display:flex;"><span>DESTINY
</span></span><span style="display:flex;"><span>DESTRUCTION
</span></span><span style="display:flex;"><span>DELIRIUM
</span></span><span style="display:flex;"><span>DELIGHT
</span></span><span style="display:flex;"><span>PIRATE
</span></span><span style="display:flex;"><span>COD
</span></span><span style="display:flex;"><span>CARP
</span></span><span style="display:flex;"><span>SALMON
</span></span></code></pre></div><p>Do pracy z plikami w języku Kotlin służy klasa <code>File</code>. Jeden z jej konstruktorów przyjmuje pełną ścieżkę do pliku w postaci <code>String</code>a. Ścieżka to inaczej lokalizacja pliku, np.: <code>C:\katalog\plik.txt</code> na Windowsie, albo <code>/Users/johnnysilverhand/katalog/plik.txt</code> na Mac&rsquo;u.</p>
<p>W IntelliJ możemy skopiować ścieżkę pliku do systemowego schowka (czyli potem będziemy mogli ją wkleić w kodzie przez <code>Ctrl + V</code>/<code>Cmd + V</code>). W panelu <code>Project</code> trzeba kliknąć prawym przyciskiem myszy na plik, wybrać opcję <code>Copy Path/Reference</code>, a potem <code>Absolute Path</code>.</p>
<p>Skopiujcie ścieżkę do pliku <code>slownik.txt</code> i wklejcie w kodzie programu do konstruktora klasy <code>File</code> (trzeba też będzie dodać odpowiedni <code>import</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> java.io.File
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>() = terminal {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> plikSłownika = File(<span style="color:#e6db74">&#34;/Users/chalup/tmp/kotlin-starter-pack/src/main/kotlin/jerz/codes/gry/wordle/slownik.txt&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Tak stworzonego obiektu możemy użyć, żeby przeczytać zawartość pliku:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> wyrazy: List&lt;String&gt; = plikSłownika.readLines()
</span></span><span style="display:flex;"><span>println(<span style="color:#e6db74">&#34;Przeczytałem </span><span style="color:#e6db74">${wyrazy.size}</span><span style="color:#e6db74"> wyrazów.&#34;</span>)
</span></span><span style="display:flex;"><span>println(<span style="color:#e6db74">&#34;Pierwszy z nich to: </span><span style="color:#e6db74">${wyrazy.first()}</span><span style="color:#e6db74">.&#34;</span>)
</span></span></code></pre></div><p>Bardzo ważne jest to, że samo stworzenie obiektu <code>File</code> nie powoduje utworzenia pliku, ani w ogóle żadnych zmian na dysku. Obiekt typu <code>File</code> nie zawiera też samej zawartości pliku. Możecie myśleć o tym jako o karteczce z adresem jakiegoś miejsca: samo napisanie jakiegoś adresu na karteczce nie powoduje, że nagle powstanie w tym miejscu dom. Natomiast mając taką karteczkę, możecie tam dojechać. Możecie też sprawdzić na mapie, czy taki adres faktycznie istnieje.</p>
<p>Inne funkcje, które mogą się nam przydać w najbliższym czasie to:</p>
<ul>
<li><code>File.exists(): Boolean</code> - sprawdza, czy plik istnieje</li>
<li><code>File.writeText(text: String)</code> - nadpisuje zawartość pliku podanym <code>text</code>em</li>
</ul>
<h1 id="czy-funkcja-jest-obiektem">Czy funkcja jest obiektem?</h1>
<p>⚠️ <strong>UWAGA</strong>: ta sekcja jest dość &ldquo;gęsta&rdquo;. Nie starajcie się tego przeczytać na telefonie na przerwie, proponuję usiąść na spokojnie w domu przy laptopie. ⚠️</p>
<h2 id="powtórka-z-typów-danych">Powtórka z typów danych</h2>
<p>Zróbmy sobie powtórkę z typów. Jakie znacie typy danych? Przypominam: typ danych to &ldquo;kształt&rdquo; obiektu (liczba, znak, itp.). Stwórzcie teraz w programie kilka stałych, podając ich typ:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> zero: Int = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> tekst: String = <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> zakres: IntRange = <span style="color:#ae81ff">1.</span>.<span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> alfabet: CharRange = <span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">..</span><span style="color:#e6db74">&#39;z&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> znak: Char = <span style="color:#e6db74">&#39;!&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> lista: List&lt;String&gt; = listOf()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> słownik: Map&lt;String, String&gt; = mapOf()
</span></span></code></pre></div><h2 id="funkcja-w-stałej">Funkcja w stałej</h2>
<p>Wszystko, co jest obiektem, ma jakiś typ. A funkcja? Czy funkcja też jest obiektem? Jaki jest jej typ? Spróbujmy stworzyć stałą zawierającą funkcję:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> wyjec = <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">wyjec</span>() { println(<span style="color:#e6db74">&#34;Buu&#34;</span>) }
</span></span></code></pre></div><p>Słowo <code>wyjec</code> podkreślone jest czerwonym wężykiem, komunikat o błędzie brzmi &ldquo;Anonymous functions with names are prohibited&rdquo;, i jest dostępny Quick Fix (czyli szybka poprawka dostępna po naciśnięciu <code>Alt + Enter</code>). Po jego zastosowaniu dostajemy kod:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> wyjec = <span style="color:#66d9ef">fun</span>() { println(<span style="color:#e6db74">&#34;Buu&#34;</span>) }
</span></span></code></pre></div><p>Nic nie świeci się na czerwono, czyli to jest działający kod! Skoro <code>wyjec</code> jest funkcją, to powinniśmy móc z nim zrobić podstawową rzecz, którą robi się z funkcjami – wywołać ją. Robi się to dokładnie w ten sam sposób co z innymi funkcjami, których używaliśmy do tej pory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>wyjec()     <span style="color:#75715e">// wypisane zostanie na ekran Buu 
</span></span></span></code></pre></div><h2 id="typ-funkcji">Typ funkcji</h2>
<p>A jaki funkcja ma typ? Zastosujemy kolejny Quick Fix, tym razem &ldquo;Specify type explicitly&rdquo; (czyli &ldquo;jednoznacznie podaj typ&rdquo;), dostępny po umieszczeniu kursora na nazwie stałej. Po jego zastosowaniu do <code>wyjca</code> zostanie dodana informacja o typie:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> wyjec: () <span style="color:#f92672">-&gt;</span> Unit = <span style="color:#66d9ef">fun</span>() { println(<span style="color:#e6db74">&#34;Buu&#34;</span>) }
</span></span></code></pre></div><p>Czyli ta funkcja ma typ zapisany jako <code>() -&gt; Unit</code>. Na jednym przykładzie dość trudno jest rozszyfrować znaczenie tego zapisu, spróbujmy stworzyć jeszcze jedną funkcję przypisaną do stałej, przy czym tym razem niech ta funkcja przyjmuje parametry i zwraca jakiś obiekt:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> zliczaczLiter = <span style="color:#66d9ef">fun</span>(tekst: String): Int { <span style="color:#66d9ef">return</span> tekst.length }
</span></span></code></pre></div><p>Po użyciu Quick Fixu &ldquo;Specify type explicitly&rdquo; dodany zostanie taki typ:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> zliczaczLiter: (String) <span style="color:#f92672">-&gt;</span> Int = <span style="color:#66d9ef">fun</span>(tekst: String): Int { <span style="color:#66d9ef">return</span> tekst.length }
</span></span></code></pre></div><p>Czyli w zapisie typu funkcji rzeczy w nawiasie po lewej stronie strzałki oznaczają parametry przyjmowane przez tę funkcję, a po prawej stronie znajduje się typ zwracany przez funkcję.</p>
<p>Wróćmy na chwilę do typu stałej <code>wyjec</code>: <code>() -&gt; Unit</code>. Pusta para nawiasów jest jasna – <code>wyjec</code> nie przyjmuje żadnych parametrów. Ale czym jest <code>Unit</code> i czemu nie widzieliśmy tego wcześniej?</p>
<p><code>Unit</code> jest domyślnym typem zwracanym przez wszystkie funkcje, więc jeśli nie podaliśmy dla funkcji typu zwracanego, to tak naprawdę zwracała ona właśnie <code>Unit</code>. Oczywiście nic nie stoi na przeszkodzie, żeby jawnie powiedzieć, że nasza funkcja zwraca <code>Unit</code> (albo wywołać <code>return Unit</code> zamiast po prostu <code>return</code>), ale jest to zbyteczne i IntelliJ będzie sugerował usunięcie tej informacji:</p>
<pre tabindex="0"><code>fun zwracamUnit(): Unit {
    return Unit
}
</code></pre><h2 id="funkcja-jako-parametr">Funkcja jako parametr</h2>
<p>Skoro funkcja jest obiektem, to można ją przekazać do innej funkcji jako parametr. Spróbujmy napisać funkcję, która powtórzy kilka razy akcję przekazaną w parametrze:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">zróbCośKilkaRazy</span>(akcja: () <span style="color:#f92672">-&gt;</span> Unit) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>.<span style="color:#ae81ff">8</span>) {
</span></span><span style="display:flex;"><span>        akcja()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Możemy przekazać tam np. funkcję <code>wyjec</code>, żeby nasz program wył wniebogłosy: <code>zróbCośKilkaRazy(wyjec)</code>.</p>
<p>Funkcje, które dostają inne funkcje jako parametr albo zwracają funkcję, nazywamy <strong>funkcjami wyższego rzędu</strong>. W bibliotece standardowej Kotlina (czyli w zestawie funkcji, które są dostępne razem z językiem), jest cała masa użytecznych funkcji wyższego rzędu, które znacznie zmniejszają ilość kodu potrzebnego do wykonania typowych operacji.</p>
<p>Przykładowo, załóżmy, że mamy listę liczb, i chcemy uzyskać listę liczb dwukrotnie większych (może wydawać się wam to bzdurnym przykładem, ale zapewniam was, cała masa kodu, który piszę na co dzień w pracy to właśnie przemaglowanie kolekcji danych).</p>
<p>Czyli dla każdego elementu listy chcemy go jakoś przekształcić, a wynik dodać do nowej listy. Bez funkcji wyższego rzędu napisalibyśmy to tak:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> liczby = listOf(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> podwojoneLiczby = mutableListOf&lt;Int&gt;()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (liczba <span style="color:#66d9ef">in</span> lista) {
</span></span><span style="display:flex;"><span>    podwojoneLiczby.add(liczba * <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Możemy napisać sobie pomocniczą funkcję wyższego rzędu, która będzie przyjmować funkcję przekształcającą element jako parametr:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">przemaglujLiczby</span>(lista: List&lt;Int&gt;, przekształcenie: (Int) <span style="color:#f92672">-&gt;</span> Int): List&lt;Int&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> wynik = mutableListOf&lt;Int&gt;()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (liczba <span style="color:#66d9ef">in</span> lista) {
</span></span><span style="display:flex;"><span>        wynik.add(przekształcenie(liczba))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> wynik
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>A następnie użyć jej w następujący sposób:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> liczby = listOf(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> podwajacz = <span style="color:#66d9ef">fun</span>(liczba: Int): Int { <span style="color:#66d9ef">return</span> liczba * <span style="color:#ae81ff">2</span> }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> podwojoneLiczby = przemaglujLiczby(liczby, podwajacz)
</span></span></code></pre></div><p>A jeszcze lepiej nie pisać własnej funkcji do przekształcania listy, tylko użyć bibliotecznej funkcji <code>map</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> liczby = listOf(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> podwajacz = <span style="color:#66d9ef">fun</span>(liczba: Int): Int { <span style="color:#66d9ef">return</span> liczba * <span style="color:#ae81ff">2</span> }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> podwojoneLiczby = liczby.map(podwajacz)
</span></span></code></pre></div><h2 id="anonimowe-funkcje-i-wyrażenia-lambda">Anonimowe funkcje i wyrażenia lambda</h2>
<p>Nie musimy naszego <code>podwajacza</code> przypisywać do stałej, można ten sam kod wpisać w wywołaniu funkcji <code>map</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> liczby = listOf(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> podwojoneLiczby = liczby.map(<span style="color:#66d9ef">fun</span>(liczba: Int): Int { <span style="color:#66d9ef">return</span> liczba * <span style="color:#ae81ff">2</span> })
</span></span></code></pre></div><p>Zamiast tworzyć anonimową funkcję, możemy użyć prostszego zapisu, tzw. <em>wyrażenia lambda</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> liczby = listOf(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> podwojoneLiczby = liczby.map({ liczba: Int <span style="color:#f92672">-&gt;</span> liczba * <span style="color:#ae81ff">2</span> })
</span></span></code></pre></div><p>Wygląda to trochę jak wnętrze funkcji, przy czym parametry i ciało funkcji oddzielone są strzałką. Nie ma też słowa kluczowego <code>return</code>: wartością zwracaną przez ten kod jest wartość ostatniego wyrażenia.</p>
<p>IntelliJ podpowie nam, że możemy pominąć okrągłe nawiasy przy wywołaniu funkcji <code>map</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> liczby = listOf(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> podwojoneLiczby = liczby.map { liczba: Int <span style="color:#f92672">-&gt;</span> liczba * <span style="color:#ae81ff">2</span> }
</span></span></code></pre></div><p>Ogólna zasada jest taka, że ostatni argument funkcji, który jest wyrażeniem lambda, można zapisać poza okrągłymi nawiasami wywołującymi funkcję. A ponieważ <code>map</code> przyjmuje tylko jeden argument, nawiasy okrągłe byłyby puste, i Kotlin zezwala na ich pominięcie.</p>
<p>W wyrażeniach lambda, które przyjmują tylko jeden parametr, można pominąć nazwę parametru. Wtedy w ciele wyrażenia będzie dostępna zmienna <code>it</code>. Tak więc nasz kod da się uprościć jeszcze bardziej:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> liczby = listOf(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> podwojoneLiczby = liczby.map { <span style="color:#66d9ef">it</span> * <span style="color:#ae81ff">2</span> }
</span></span></code></pre></div><p>Inną przydatną funkcją dostępną dla listy jest <code>filter</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">List</span>&lt;T&gt;.filter(predicate: (T) <span style="color:#f92672">-&gt;</span> Boolean): List&lt;T&gt;
</span></span></code></pre></div><p>Funkcja <code>filter</code> tworzy nową listę, a następnie dodaje do niej wszystkie elementy ze starej listy, dla których funkcja <code>predicate</code> zwróci wartość <code>true</code>. Czyli &ldquo;odfiltrowuje&rdquo; ona listę danych. Przykładowo:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> liczby = listOf(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> parzysteLiczby = liczby.filter { <span style="color:#66d9ef">it</span> % <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> }
</span></span></code></pre></div><p>Znacznie prostsze niż:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> liczby = listOf(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> parzysteLiczby = mutableListOf&lt;Int&gt;()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (liczba <span style="color:#66d9ef">in</span> liczby) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (liczba % <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        parzysteLiczby.add(liczba)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Używanie właściwych funkcji wyższego rzędu nie tylko skraca ilość pisanego kodu, ale przede wszystkim ułatwia jego czytanie. Jeśli widzę wywołanie <code>map</code>, wiem, czego mogę się spodziewać. Jeśli widzę pętlę po elementach listy, muszę dokładnie wczytać się w kod, żeby zrozumieć, co ona faktycznie robi.</p>
<p>Na kolejnych zajęciach będziemy poznawać kolejne funkcje tego typu, tak więc upewnijcie się, że dobrze rozumiecie powyższy materiał!</p>

</main>

  <footer>
  
  
  </footer>
  </body>
</html>

