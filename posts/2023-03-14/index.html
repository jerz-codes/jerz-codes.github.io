<!DOCTYPE html>
<html lang="pl-pl">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ZajÄ™cia 17: Doom Fire, c.d. | jerz.codes</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@400;700&display=swap">
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">ğŸ </a></li>
      
      <li><a href="/zapisy/">Zapisy</a></li>
      
      <li><a href="/faq/">FAQ</a></li>
      
      <li><a href="/kontakt/">Kontakt</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">ZajÄ™cia 17: Doom Fire, c.d.</span></h1>

<h2 class="date">2023/03/14</h2>
</div>

<main>
<div>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#sytuacja-po-poprzednich-zajÄ™ciach">Sytuacja po poprzednich zajÄ™ciach</a></li>
    <li><a href="#dlaczego-to-tak-wolno-dziaÅ‚a">Dlaczego to tak wolno dziaÅ‚a?!?!</a>
      <ul>
        <li><a href="#dlaczego-to-w-ogÃ³le-dziaÅ‚a">Dlaczego to w ogÃ³le dziaÅ‚a?!?!</a></li>
        <li><a href="#stringbuilder"><code>StringBuilder</code></a></li>
      </ul>
    </li>
    <li><a href="#tÄ™cza--ogieÅ„-">TÄ™cza? ğŸ˜’ OgieÅ„? ğŸ˜š</a></li>
  </ul>
</nav>
</div>
<h1 id="sytuacja-po-poprzednich-zajÄ™ciach">Sytuacja po poprzednich zajÄ™ciach</h1>
<p>MiaÅ‚ byÄ‡ ogieÅ„, wyszedÅ‚ zachÃ³d sÅ‚oÅ„ca w piekielnych kolorach; w dodatku wszystko dziaÅ‚a koszmarnie wolno. PodsumowujÄ…c â€“ szaÅ‚u nie ma.</p>
<h1 id="dlaczego-to-tak-wolno-dziaÅ‚a">Dlaczego to tak wolno dziaÅ‚a?!?!</h1>
<p>Najpierw zajmiemy siÄ™ bardziej palÄ…cÄ… kwestiÄ…: prÄ™dkoÅ›ciÄ… animacji. W zaleÅ¼noÅ›ci od komputera osiÄ…gaÄ‡ bÄ™dziemy pewnie 2-3 klatki na sekundÄ™ (a w przypadku wolniejszych maszyn jednÄ… klatkÄ™ na 2-3 sekundy). Brzmi absurdalnie, zwÅ‚aszcza biorÄ…c pod uwagÄ™ moc obliczeniowÄ… waszych komputerÃ³w.</p>
<p>Bardzo uproszczony pseudokod rysowania ognia wyglÄ…da nastÄ™pujÄ…co:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>dla kaÅ¼dego kwadracika 
</span></span><span style="display:flex;"><span>    narysuj spacjÄ™ w odpowiednim kolorze
</span></span></code></pre></div><p>&ldquo;Rysowanie&rdquo; odbywa siÄ™ za pomocÄ… dodawania do zmiennej <code>kartka</code> typu <code>String</code> kolejnych spacji i instrukcji ANSI do zmiany koloru tÅ‚a, tak wiÄ™c bardziej szczegÃ³Å‚owy pseudokod to:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>przygotuj zmiennÄ… &#34;kartka&#34; z instrukcjÄ… ANSI do czyszczenia ekranu 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>dla kaÅ¼dego kwadracika
</span></span><span style="display:flex;"><span>    do zmiennej &#34;kartka&#34; dodaj instrukcjÄ™ ANSI do zmiany koloru
</span></span><span style="display:flex;"><span>    do zmiennej &#34;kartka&#34; dodaj znak spacji &#39; &#39;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>wypisz zmiennÄ… &#34;kartka&#34; na ekran
</span></span></code></pre></div><p>Samo przygotowanie zmiennej albo wypisanie jej na ekran nie powinno byÄ‡ wolne (gdyby byÅ‚o, problemy pojawiÅ‚yby siÄ™ rÃ³wnieÅ¼ przy Biedamatrixowej animacji). Problem musi leÅ¼eÄ‡ gdzieÅ› w pÄ™tli &ldquo;jadÄ…cej&rdquo; po wszystkich pikselach.</p>
<p>ZastanÃ³wmy siÄ™, ile faktycznie wykonujemy tam pracy. Mamy <code>120 * 80 = 9600</code> kwadracikÃ³w, i dla kaÅ¼dego z nich dodajemy do kartki tekst w rodzaju <code>&quot;â›[48;2;255;90;90m &quot;</code> (spacja poprzedzona zmianÄ… koloru tÅ‚a), czyli ok. 18 znakÃ³w. ÅÄ…cznie nasza kartka bÄ™dzie mieÄ‡ ok. <code>170000</code> znakÃ³w. MoÅ¼e wydawaÄ‡ siÄ™ to duÅ¼Ä… liczbÄ…, ale dla waszych komputerÃ³w to powinna byÄ‡ betka: kaÅ¼dy znak zajmuje 1 bajt pamiÄ™ci, tak wiÄ™c 170 tysiÄ™cy znakÃ³w, to 170kb. Wasze komputery majÄ… zapewne conajmniej 4GB pamiÄ™ci, czyli 4 miliony kilobajtÃ³w. W porÃ³wnaniu 170kb to naprawdÄ™ niewiele.</p>
<p>Musimy spojrzeÄ‡ siÄ™ na to z jeszcze wiÄ™kszego przybliÅ¼enia.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>przygotuj zmiennÄ… &#34;kartka&#34;
</span></span><span style="display:flex;"><span>dodaj do tekstu ze zmiennej &#34;kartka&#34; 18 znakÃ³w dla pierwszego pikselika 
</span></span><span style="display:flex;"><span>dodaj do tekstu ze zmiennej &#34;kartka&#34; 18 znakÃ³w dla drugiego pikselika 
</span></span><span style="display:flex;"><span>dodaj do tekstu ze zmiennej &#34;kartka&#34; 18 znakÃ³w dla trzeciego pikselika
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>dodaj do tekstu ze zmiennej &#34;kartka&#34; 18 znakÃ³w dla pikselika nr 9600 
</span></span></code></pre></div><p>W Kotlinie, &ldquo;dodawanie&rdquo; dwÃ³ch tekstÃ³w to tak naprawdÄ™ tworzenie trzeciego tekstu na ich podstawie. Tak wiÄ™c kod naszej pÄ™tli wyglÄ…da tak:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>przygotuj zmiennÄ… &#34;kartka&#34;
</span></span><span style="display:flex;"><span>stwÃ³rz tekst z zawartoÅ›ci &#34;kartki&#34; i 18 znakÃ³w dla pierwszego pikselika i zapisz go w &#34;kartce&#34; 
</span></span><span style="display:flex;"><span>stwÃ³rz tekst z nowej zawartoÅ›ci &#34;kartki&#34; i 18 znakÃ³w dla drugiego pikselika i zapisz go w &#34;kartce&#34;
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>itd. itp.
</span></span></code></pre></div><p>Tak wiÄ™c ostatecznie nasza <code>kartka</code> bÄ™dzie miaÅ‚a 170kb, ale po drodze stworzymy caÅ‚Ä… masÄ™ poÅ›rednich wartoÅ›ci. Policzmy, ile z grubsza bÄ™dziemy na to potrzebowaÄ‡ miejsca. Dla kaÅ¼dego pikselika nasza kartka bÄ™dzie rosnÄ…Ä‡ o ~18 bajtÃ³w, czyli Å‚Ä…cznie bÄ™dziemy potrzebowaÄ‡ na to:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>18 + 36 + 54 + 72 + ... + 172800
</span></span></code></pre></div><p>Czyli inaczej:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>18 * (1 + 2 + 3 + 4 + ... + 9600)
</span></span></code></pre></div><p>Suma w nawiasie to suma <a href="https://pl.wikipedia.org/wiki/Ci%C4%85g_arytmetyczny">ciÄ…gu arytmetycznego</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>18 * (9600 + 1) * 9600 / 2 
</span></span></code></pre></div><p>DwÃ³jka upraszcza siÄ™ z <code>18</code>, <code>+1</code> w nawiasach pomijamy, bo nie robi to duÅ¼ej rÃ³Å¼nicy, zaokrÄ…glamy wszystkie rzeczy do najbliÅ¼szej potÄ™gi 10 i dostajemy z grubsza:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>10 * 10000 * 10000 = 1000 * 1000 * 1000 = 1GB ğŸ™€
</span></span></code></pre></div><p>Na jednÄ… klatkÄ™ animacji! A my chcemy to wykonywaÄ‡ 60 razy w ciÄ…gu sekundy! Nic dziwnego, Å¼e nasze komputery siÄ™ nie wyrabiajÄ….</p>
<h2 id="dlaczego-to-w-ogÃ³le-dziaÅ‚a">Dlaczego to w ogÃ³le dziaÅ‚a?!?!</h2>
<p>Nasze komputery majÄ… 4, 8, albo 16GB pamiÄ™ci RAM, wiÄ™c jakim cudem ten program w ogÃ³le dziaÅ‚a, jeÅ›li w ciÄ…gu sekundy potrzebne mu jest 60GB pamiÄ™ci? Nie powinien siÄ™ wykrzaczyÄ‡ z komunikatem w stylu &ldquo;za maÅ‚o pamiÄ™ci&rdquo;?</p>
<p>GdybyÅ›my sprÃ³bowali stworzyÄ‡ jeden tekst z 60 miliardami znakÃ³w, nasze komputery faktycznie by zaprotestowaÅ‚y. Nasz program w ciÄ…gu sekundy tworzy tysiÄ…ce (a moÅ¼e to juÅ¼ idzie w miliony?) obiektÃ³w o Å‚Ä…cznym rozmiarze 60GB, ale najwiÄ™ksze z nich, peÅ‚ne &ldquo;kartki&rdquo;, ktÃ³re wypisujemy na ekran, zajmujÄ… jedynie ~170kb. Po prostu stworzenie tych wszystkich obiektÃ³w i posprzÄ…tanie ich zajmuje bardzo duÅ¼o czasu.</p>
<p>Obrazowo moÅ¼na wyobraziÄ‡ to sobie w nastÄ™pujÄ…cy sposÃ³b: w pokoju (naszym programie) siedzi stwÃ³r zwany Kotlinem i wyczarowuje kolejne &ldquo;klocki&rdquo; z tekstami, Å‚Ä…czy je ze sobÄ…, itd. JeÅ›li coÅ› nie jest mu juÅ¼ potrzebne, wyrzuca to w kÄ…t. Co jakiÅ› czas do pokoju zaglÄ…da kolega Kotlina, Åšmieciarz (ang. <em>garbage collector</em>), i zabiera wszystkie wciÅ›niÄ™te w kÄ…t i niepotrzebne juÅ¼ rzeczy. Zazwyczaj dzieje siÄ™ to bez przerw w dziaÅ‚aniu programu â€“ Åšmieciarz nie przeszkadza Kotlinowi w jego pracy i po cichutku ogarnia baÅ‚agan.</p>
<p>Czasami zdarza siÄ™ jednak tak, Å¼e Kotlin naprodukuje tyle szpejÃ³w, Å¼e przestajÄ… siÄ™ one mieÅ›ciÄ‡ w pokoju. Nie moÅ¼e nic wiÄ™cej zrobiÄ‡, bo nie ma miejsca na wyczarowywane przez niego klocki. Siada wtedy na haÅ‚dzie Å›mieci i woÅ‚a Åšmieciarza na ratunek. Program zostaje zatrzymany, dopÃ³ki Åšmieciarz nie wyniesie niepotrzebnych rzeczy.</p>
<p>Przypuszczam, Å¼e podobna sytuacja dzieje siÄ™ w naszym programie nawet kilka razy na klatkÄ™ animacji i stÄ…d biorÄ… siÄ™ nasze problemy z wydajnoÅ›ciÄ… programu.</p>
<h2 id="stringbuilder"><code>StringBuilder</code></h2>
<p>RozwiÄ…zaniem naszego problemu jest uÅ¼ycie specjalnego narzÄ™dzia do Å‚Ä…czenia <code>String</code>Ã³w â€“ klasy <code>StringBuilder</code>. Do obiektu tej klasy moÅ¼na dodawaÄ‡ kolejne elementy, nie powodujÄ…c lawinowego generowania Å›mieci.</p>
<p>ZmieÅ„my zatem naszÄ… kartkÄ™. Na poczÄ…tku, zamiast tworzyÄ‡ pusty <code>String</code>, uÅ¼yjmy konstruktora typu <code>StringBuilder</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#f92672">- var kartka = &#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+ val kartka = StringBuilder()
</span></span></span></code></pre></div><p>Nasza <code>kartka</code> nie musi byÄ‡ juÅ¼ zmiennÄ… (<code>var</code>), moÅ¼e byÄ‡ to staÅ‚a (<code>val</code>). Co prawda bÄ™dziemy do niej dodawaÄ‡ teksty, ale w dalszym ciÄ…gu bÄ™dzie to ten sam obiekt.</p>
<p>Po tej zmianie wszystkie <code>kartka += â€¦</code> zacznÄ… Å›wieciÄ‡ siÄ™ na czerwono. Obiekt <code>StringBuilder</code> w Kotlinie nie obsÅ‚uguje tego zapisu. Zamiast tego, bÄ™dziemy musieli uÅ¼yÄ‡ normalnej funkcji <code>append</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#f92672">- kartka += Ansi.wyczyÅ›Ä‡Ekran()
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+ kartka.append(Ansi.wyczyÅ›Ä‡Ekran())
</span></span></span></code></pre></div><p>Po tych wszystkich zabiegach nasz program powinien zaczÄ…Ä‡ dziaÅ‚aÄ‡ sprawnie. Wreszcie moÅ¼emy zabraÄ‡ siÄ™ za ciekawsze rzeczy, czyli ulepszenie naszej animacji. Zanim do tego przejdziemy, chciaÅ‚bym wam zwrÃ³ciÄ‡ uwagÄ™ na ogÃ³lniejszÄ… lekcjÄ™, wynikajÄ…cÄ… z naszej przygody z dodawaniem do siebie <code>String</code>Ã³w.</p>
<p>W potocznej terminologii programistÃ³w &ldquo;wykrÄ™ciliÅ›my n kwadrat&rdquo;. Czyli nasz program miaÅ‚ coÅ› zrobiÄ‡ ze zbiorem N
elementÃ³w, ale nasz algorytm potrzebowaÅ‚ na to NÂ² krokÃ³w albo NÂ² pamiÄ™ci. Wasze komputery sÄ… naprawdÄ™ bardzo szybkie, wykonywanie kilku milionÃ³w operacji to dla nich betka. Wykonanie kilkunastu milionÃ³w milionÃ³w operacji zajmie im nieco wiÄ™cej czasu, prawdopodobnie zbyt duÅ¼o, zwÅ‚aszcza w kontekÅ›cie gier i animacji, gdzie oczekujemy 60 klatek na sekundÄ™.</p>
<h1 id="tÄ™cza--ogieÅ„-">TÄ™cza? ğŸ˜’ OgieÅ„? ğŸ˜š</h1>
<p>W naszej animacji kaÅ¼dy kwadracik jest &ldquo;ogrzewany&rdquo; przez kwadracik poniÅ¼ej. To &ldquo;ciepÅ‚o&rdquo; rozprzestrzenia siÄ™ idealnie rÃ³wnomiernie, co daje nam w wyniku efekt przypominajÄ…cy tÄ™czÄ™ (w nieco piekielnej palecie kolorÃ³w).</p>
<p>Prawdziwy ogieÅ„ zachowuje siÄ™ trochÄ™ inaczej. Po pierwsze, nie ma perfekcyjnie rÃ³wnomiernego ÅºrÃ³dÅ‚a ciepÅ‚a. Po drugie, w powietrzu powstajÄ… zawirowania, tu i Ã³wdzie powietrze nagrzewa siÄ™ bardziej, lub mniej. Musimy do naszej funkcji <code>animujOgieÅ„</code> dodaÄ‡ nieco losowoÅ›ci.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span>fun animujOgieÅ„(ekran: MutableList&lt;MutableList&lt;Int&gt;&gt;) {
</span></span><span style="display:flex;"><span>    // dla kaÅ¼dej linijki oprÃ³cz ostatniej
</span></span><span style="display:flex;"><span>    for (y in 1..(WYSOKOSC - 1)) {
</span></span><span style="display:flex;"><span>        // dla kaÅ¼dego pikselka
</span></span><span style="display:flex;"><span>        for (x in 1..SZEROKOSC) {
</span></span><span style="display:flex;"><span>            // popatrz na kratkÄ™ poniÅ¼ej
</span></span><span style="display:flex;"><span>            val kratkaPoniÅ¼ej = ekran[y][x - 1]
</span></span><span style="display:flex;"><span><span style="color:#f92672">-           val nowaWartoÅ›Ä‡ = (kratkaPoniÅ¼ej - 1).coerceAtLeast(0)
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+           val nowaWartoÅ›Ä‡ = (kratkaPoniÅ¼ej - (0..1).random()).coerceAtLeast(0)
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>
</span></span><span style="display:flex;"><span>            // ustaw nowÄ… wartoÅ›Ä‡ dla kratki
</span></span><span style="display:flex;"><span>            ekran[y - 1][x - 1] = nowaWartoÅ›Ä‡
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Od razu lepiej!</p>
<p><img src="doom-prosto.png" alt="Proste pÅ‚omienie"></p>
<p>Po kilku sekundach wyglÄ…da to nieÅºle, ale pierwsze kilkadziesiÄ…t klatek animacji wyglÄ…da dziwnie:</p>
<p><img src="doom-krawedz.png" alt="Tyraliera"></p>
<p>Wynika to z faktu, Å¼e kaÅ¼dy kwadracik zawsze zostaje ogrzany przez kratkÄ™ poniÅ¼ej. W rzeczywistoÅ›ci drewno pali siÄ™ nierÃ³wnomiernie, a w powietrzu powstajÄ… zawirowania. Å»eby to zasymulowaÄ‡, algorytm naszej animacji powinien stwarzaÄ‡ moÅ¼liwoÅ›Ä‡, Å¼e jakiÅ› kwadracik w ogÃ³le nie zmieni koloru.</p>
<p>Po pierwsze, musimy &ldquo;odwrÃ³ciÄ‡&rdquo; sposÃ³b, w jaki myÅ›limy o przenoszeniu poziom ciepÅ‚a: zamiast dla kaÅ¼dego kwadracika &ldquo;patrzeÄ‡ siÄ™&rdquo; na poziom ciepÅ‚a kwadracika poniÅ¼ej, powinniÅ›my dla kaÅ¼dego ÅºrÃ³dÅ‚a ciepÅ‚a ogrzaÄ‡ kwadrat powyÅ¼ej:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span>fun animujOgieÅ„(ekran: MutableList&lt;MutableList&lt;Int&gt;&gt;) {
</span></span><span style="display:flex;"><span>    // dla kaÅ¼dej linijki oprÃ³cz ostatniej
</span></span><span style="display:flex;"><span>    for (y in 1..(WYSOKOSC - 1)) {
</span></span><span style="display:flex;"><span>        // dla kaÅ¼dego pikselka
</span></span><span style="display:flex;"><span>        for (x in 1..SZEROKOSC) {
</span></span><span style="display:flex;"><span><span style="color:#f92672">-           val kratkaPoniÅ¼ej = ekran[y][x - 1]
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+           val mojaWartoÅ›Ä‡ = ekran[y][x - 1]
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span><span style="color:#f92672">-           val nowaWartoÅ›Ä‡ = (mojaWartoÅ›Ä‡ - (0..1).random()).coerceAtLeast(0)
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+           val nowaWartoÅ›Ä‡ = (kratkaPoniÅ¼ej - (0..1).random()).coerceAtLeast(0)
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>
</span></span><span style="display:flex;"><span>            // ustaw nowÄ… wartoÅ›Ä‡ dla ogrzewanej kratki
</span></span><span style="display:flex;"><span>            ekran[y - 1][x - 1] = nowaWartoÅ›Ä‡
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Na razie tylko zmieniliÅ›my nazwy staÅ‚ych â€“ sam algorytm na razie siÄ™ nie zmieniÅ‚.</p>
<p>Czas na drugi krok: musimy dodaÄ‡ losowoÅ›Ä‡ rÃ³wnieÅ¼ do przenoszenia ciepÅ‚a. Do wspÃ³Å‚rzÄ™dnej kratki, ktÃ³ra zostanie ogrzana, dodamy losowÄ… wartoÅ›Ä‡ z przedziaÅ‚u <code>-1..1</code> (musimy teÅ¼ zadbaÄ‡ o to, Å¼eby wylosowany <code>x</code> byÅ‚ z poprawnego przedziaÅ‚u; uÅ¼yjemy do tego funkcji <code>coerceIn</code>, dziaÅ‚ajÄ…cej na podobnej zasadzie co <code>coerceAtLeast</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span>fun animujOgieÅ„(piksele: MutableList&lt;MutableList&lt;Int&gt;&gt;) {
</span></span><span style="display:flex;"><span>    // dla kaÅ¼dej linijki(oprÃ³cz ostatniej)
</span></span><span style="display:flex;"><span>    for (y in 1..(WYSOKOSC - 1)) {
</span></span><span style="display:flex;"><span>        // dla kaÅ¼dego pikselka
</span></span><span style="display:flex;"><span>        for (x in 1..SZEROKOSC) {
</span></span><span style="display:flex;"><span>            val mojaWartoÅ›Ä‡ = piksele[y][x - 1]
</span></span><span style="display:flex;"><span>            val nowaWartoÅ›Ä‡ = (mojaWartoÅ›Ä‡ - (0..1).random()).coerceAtLeast(0)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">+           val xOgrzanejKratki = (x - 1 + (-1..1).random()).coerceIn(0..SZEROKOSC - 1)
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>            // ustaw nowÄ… wartoÅ›Ä‡ dla ogrzewanej kratki
</span></span><span style="display:flex;"><span><span style="color:#f92672">-           ekran[y - 1][x - 1] = nowaWartoÅ›Ä‡
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+           ekran[y - 1][xOgrzanejKratki] = nowaWartoÅ›Ä‡
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="doom-fire.png" alt=""></p>
<p>JeÅ›li zmianÄ™ <code>x</code> bÄ™dziemy losowaÄ‡ z niesymetrycznego przedziaÅ‚u, otrzymamy efekt ognia rozwiewanego przez wiart:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#f92672">-           val xOgrzanejKratki = (x - 1 + (-1..1).random()).coerceIn(0..SZEROKOSC - 1)
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+           val xOgrzanejKratki = (x - 1 + (-3..1).random()).coerceIn(0..SZEROKOSC - 1)
</span></span></span></code></pre></div><p><img src="doom-firewind.png" alt=""></p>

</main>

  <footer>
  
  
  </footer>
  </body>
</html>

