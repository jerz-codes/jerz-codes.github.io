<!DOCTYPE html>
<html lang="pl-pl">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ZajÄ™cia 10: `Map` i `enum class` | jerz.codes</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@400;700&display=swap">
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">ğŸ </a></li>
      
      <li><a href="/zapisy/">Zapisy</a></li>
      
      <li><a href="/faq/">FAQ</a></li>
      
      <li><a href="/kontakt/">Kontakt</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">ZajÄ™cia 10: <code>Map</code> i <code>enum class</code></span></h1>

<h2 class="date">2023/01/03</h2>
</div>

<main>
<div>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#po-jakie-licho-sÄ…-nam-klasy"><em>&ldquo;Po jakie licho sÄ… nam klasy?&rdquo;</em></a></li>
    <li><a href="#nowy-materiaÅ‚">Nowy materiaÅ‚</a>
      <ul>
        <li><a href="#enum-class"><code>enum class</code></a></li>
        <li><a href="#map"><code>Map</code></a></li>
        <li><a href="#sÅ‚ownik">SÅ‚ownik</a></li>
      </ul>
    </li>
    <li><a href="#co-dalej">Co dalej?</a></li>
  </ul>
</nav>
</div>
<h1 id="po-jakie-licho-sÄ…-nam-klasy"><em>&ldquo;Po jakie licho sÄ… nam klasy?&rdquo;</em></h1>
<p>Pytanie, ktÃ³re zadaÅ‚ mi po ostatnich zajÄ™ciach Jurek, i ktÃ³re pewnie niejednemu z was przyszÅ‚o do gÅ‚owy.</p>
<p>Programy, ktÃ³re napisaliÅ›my do tej pory, faktycznie daÅ‚o napisaÄ‡ siÄ™ bez tworzenia wÅ‚asnych klas. Przy kolejnych, bardziej skomplikowanych programach, korzystanie jedynie z wbudowanych typÃ³w danych bÄ™dzie albo niepraktyczne, albo wrÄ™cz niemoÅ¼liwe. Dlatego teÅ¼ chciaÅ‚em powoli zaczÄ…Ä‡ wprowadzaÄ‡ pojÄ™cie klas.</p>
<p>Na przykÅ‚ad, punkt na dwuwymiarowej pÅ‚aszczyÅºnie moÅ¼na opisaÄ‡ i przekazywaÄ‡ do funkcji jako dwie liczby <code>x</code> i <code>y</code>. Nie da siÄ™ natomiast napisaÄ‡ funkcji, ktÃ³ra zwrÃ³ci dwie liczby: instrukcja <code>return</code> moÅ¼e zwrÃ³ciÄ‡ tylko jeden obiekt. Tak wiÄ™c funkcja, ktÃ³ra miaÅ‚aby zwracaÄ‡ wspÃ³Å‚rzÄ™dne <code>x</code> i <code>y</code>, musi je &ldquo;opakowaÄ‡&rdquo; w jakiÅ› obiekt.</p>
<p>Przed podobnym dylematem staniemy, jeÅ›li bÄ™dziemy potrzebowaÄ‡ listy punktÃ³w: teoretycznie moÅ¼liwe jest stworzenie dwÃ³ch list (jedna na wspÃ³Å‚rzÄ™dne <code>x</code>, druga na wspÃ³Å‚rzÄ™dne <code>y</code>), albo wrzucanie wspÃ³Å‚rzÄ™dnych naprzemiennie do jednej listy (czyli zrobienie <code>listOf(x1, y1, x2, y2, itd.)</code>), albo zastosowanie jeszcze bardziej karkoÅ‚omnej konstrukcji. Lepiej bÄ™dzie jednak utworzyÄ‡ <code>data class Point(val x: Int, val y: Int)</code>, i korzystaÄ‡ po prostu z <code>List&lt;Point&gt;</code>.</p>
<p>Inna korzyÅ›Ä‡ z uÅ¼ywania wÅ‚asnych typÃ³w danych to lepsze odzwierciedlenie w kodzie problemu, nad ktÃ³rym pracujemy. Fachowo programiÅ›ci nazywajÄ… to &ldquo;modelowaniem domeny&rdquo;. Chodzi z grubsza o to, Å¼e jeÅ›li w naszym programie robimy jakieÅ› rzeczy z punktami na pÅ‚aszczyÅºnie, to dobrze jest mieÄ‡ klocki, ktÃ³re odpowiadajÄ… tym punktom, zamiast Å¼onglowaÄ‡ &ldquo;luÅºnymi&rdquo; <code>Int</code>ami. Dobre &ldquo;zamodelowanie&rdquo; obiektÃ³w znacznie uÅ‚atwia pisanie pozostaÅ‚ych czÄ™Å›ci programu i utrudnia zrobienie bÅ‚Ä™dÃ³w.</p>
<h1 id="nowy-materiaÅ‚">Nowy materiaÅ‚</h1>
<h2 id="enum-class"><code>enum class</code></h2>
<p>W programie &ldquo;KÃ³Å‚ko i KrzyÅ¼yk&rdquo; przechowywaliÅ›my planszÄ™ jako <code>List&lt;String&gt;</code>. WspomniaÅ‚em wÃ³wczas, Å¼e nie jest to najlepsze rozwiÄ…zanie. UÅ¼ycie takiej struktury umoÅ¼liwia popeÅ‚nienie bÅ‚Ä™dÃ³w w stylu uÅ¼ywanie w jednym miejscu maÅ‚ego <code>x</code> a w innych duÅ¼ego <code>X</code> to reprezentowania symbolu krzyÅ¼yka.</p>
<p>Zamiast korzystaÄ‡ ze <code>String</code>&lsquo;Ã³w moglibyÅ›my stworzyÄ‡ wÅ‚asny typ opisujÄ…cy symbol na planszy. PoznaliÅ›my do tej pory dwa rodzaje wÅ‚asnych typÃ³w:</p>
<ul>
<li><code>class</code> (oraz <code>data class</code>), gdy chcemy mieÄ‡ moÅ¼liwoÅ›Ä‡ stworzenia dowolnej iloÅ›ci obiektÃ³w jakiegoÅ› typu</li>
<li><code>object</code>, gdy zaleÅ¼y nam na tym, Å¼eby istniaÅ‚ tylko jeden obiekt tego typu (pamiÄ™tacie <code>MisterneRÄ™cznieWystruganeKrzesÅ‚oWujkaWÅ‚adka</code>?)</li>
</ul>
<p>Å»adne z tych rozwiÄ…zaÅ„ nie pasuje do &ldquo;KÃ³Å‚ka i KrzyÅ¼yk&rdquo; gdzie potrzebujemy dokÅ‚adnie dwÃ³ch obiektÃ³w naszego nowego typu: jednego dla kÃ³Å‚ek, drugiego dla krzyÅ¼ykÃ³w. Potrzebny bÄ™dzie nam nowy rodzaj obiektÃ³w: <code>enum class</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Symbol</span> { KÃ“ÅKO, KRZYÅ»YK }
</span></span></code></pre></div><p>PierwszÄ… rzeczÄ… w ciele obiektÃ³w typu <code>enum</code> jest oddzielona przecinkami lista wszystkich obiektÃ³w tego typu. Dla wartoÅ›ci <code>enum</code>&lsquo;Ã³w przyjÄ™Å‚o siÄ™ stosowaÄ‡ nazwy w formie <code>SNAKE_UPPER_CASE</code>, czyli wyrazy pisane wielkÄ… literÄ… oddzielone znakiem <code>_</code>.</p>
<p>MoÅ¼emy pÃ³Åºniej uÅ¼yÄ‡ tego typu do przechowywania danych o planszy:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#75715e">// uÅ¼ywamy opcjonalnego typu, null bÄ™dzie oznaczaÅ‚ puste pole
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> plansza = mutableListOf&lt;Symbol?&gt;()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>.<span style="color:#ae81ff">9</span>) { plansza.add(<span style="color:#66d9ef">null</span>) }
</span></span></code></pre></div><p>Podobnie jak przypadku innych <code>class</code>, moÅ¼emy do naszego <code>enum</code>a dodaÄ‡ konstruktor:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Symbol</span>(<span style="color:#66d9ef">val</span> znaczek: Char) {
</span></span><span style="display:flex;"><span>    KÃ“ÅKO,
</span></span><span style="display:flex;"><span>    KRZYÅ»YK
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Linijki z <code>KÃ“ÅKO</code> i <code>KRZYÅ»YK</code> zostanÄ… podkreÅ›lone na czerwono: w tych miejscach tak naprawdÄ™ tworzymy obiekty typu <code>Symbol</code>, a wÅ‚aÅ›nie powiedzieliÅ›my, Å¼e kaÅ¼dy obiekt tego typu powinien otrzymaÄ‡ w konstruktorze <code>znaczek</code> typu <code>Char</code>. Musimy dodaÄ‡ odpowiednie wywoÅ‚ania konstruktorÃ³w:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Symbol</span>(<span style="color:#66d9ef">val</span> znaczek: Char) {
</span></span><span style="display:flex;"><span>    KÃ“ÅKO(<span style="color:#e6db74">&#39;O&#39;</span>),
</span></span><span style="display:flex;"><span>    KRZYÅ»YK(<span style="color:#e6db74">&#39;X&#39;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="map"><code>Map</code></h2>
<p>Poznajmy kolejnÄ… strukturÄ™ danych: <code>Map</code>.</p>
<p>W niektÃ³rych jÄ™zykach programowania (np: w Pythonie czy w C#) ta struktura danych nazywana jest sÅ‚ownikiem i myÅ›lÄ™, Å¼e na tym przykÅ‚adzie bÄ™dzie wam to Å‚atwo wytÅ‚umaczyÄ‡.</p>
<p>ZaÅ‚Ã³Å¼my, Å¼e mamy &ldquo;papierowy&rdquo; sÅ‚ownik polsko-angielski i potrzebujemy przetÅ‚umaczyÄ‡ kilka wyrazÃ³w. KaÅ¼dy wpis w takim sÅ‚owniku skÅ‚ada siÄ™ z dwÃ³ch czÄ™Å›ci: polskiego wyrazu oraz jego angielskiego tÅ‚umaczenia (zazwyczaj nie jest to pojedynczy wyraz w jÄ™zyku angielskim, ale kilka synonimÃ³w; w niektÃ³rych sÅ‚ownikach moÅ¼na teÅ¼ znaleÅºÄ‡ przykÅ‚adowe zdania). HasÅ‚a w sÅ‚owniku uÅ‚oÅ¼one sÄ… w porzÄ…dku alfabetycznym, Å¼eby uÅ‚atwiÄ‡ szukanie tÅ‚umaczeÅ„.</p>
<p>A czy jest moÅ¼liwe przetÅ‚umaczenie wyrazÃ³w &ldquo;w drugÄ… stronÄ™&rdquo;, tj. angielskich wyrazÃ³w na jÄ™zyk polski przy uÅ¼yciu sÅ‚ownika polsko-angielskiego? Czysto teoretycznie tak â€“ wystarczy &ldquo;tylko&rdquo; przeczytaÄ‡ caÅ‚y sÅ‚ownik od deski do deski. Jest to moÅ¼liwe, ale niepraktyczne.</p>
<p>Na takiej samej zasadzie dziaÅ‚a struktura danych <code>Map</code>. KaÅ¼dy wpis w naszej &ldquo;mapie&rdquo; skÅ‚ada siÄ™ z dwÃ³ch elementÃ³w: Klucza i WartoÅ›ci. W naszej sÅ‚ownikowej analogii Klucz to polski wyraz, a WartoÅ›Ä‡ to wpis zawierajÄ…cy angielskie tÅ‚umaczenia. WartoÅ›ci moÅ¼na Å‚atwo i szybko odszukaÄ‡, jeÅ›li znamy pasujÄ…cy Klucz, a przeszukiwanie samych WartoÅ›ci jest moÅ¼liwe, ale nieefektywne.</p>
<h2 id="sÅ‚ownik">SÅ‚ownik</h2>
<p>Napiszmy prosty program tÅ‚umaczÄ…cy polskie wyrazy na jÄ™zyk angielski.</p>
<p>TÅ‚umaczenia bÄ™dziemy oczywiÅ›cie przechowywaÄ‡ w strukturze Map. MoÅ¼emy jÄ… utworzyÄ‡ przy uÅ¼yciu funkcji <code>mapOf</code>. Podobnie, jak w przypadku <code>listOf</code>, bÄ™dziemy musieli podaÄ‡ w trÃ³jkÄ…tnych nawiasach, jakiego typu bÄ™dÄ… Klucze i
WartoÅ›ci w naszej mapie. Dla uproszczenia uÅ¼yjmy typu <code>String</code> zarÃ³wno dla Kluczy, jak i WartoÅ›ci:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> sÅ‚ownik = mapOf&lt;String, String&gt;()
</span></span></code></pre></div><p>W nawiasach okrÄ…gÅ‚ych moÅ¼emy podaÄ‡ zawartoÅ›Ä‡ naszej <code>Map</code>y. KaÅ¼dy element w <code>Map</code>ie skÅ‚ada siÄ™ z dwÃ³ch czÄ™Å›ci, Klucza i WartoÅ›ci, wiÄ™c musimy uÅ¼yÄ‡ nastÄ™pujÄ…cej skÅ‚adni:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> sÅ‚ownik = mapOf&lt;String, String&gt;(
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;pies&#34;</span> to <span style="color:#e6db74">&#34;dog&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>SÅ‚Ã³wko <code>to</code> pomiÄ™dzy dwoma tekstami wyglÄ…da trochÄ™ dziwnie, ale w rzeczywistoÅ›ci to jest po prostu wywoÅ‚anie funkcji. Funkcja biblioteczna <code>to</code> zostaÅ‚a oznaczona specjalnym modyfikatorem <code>infix</code>, Å¼eby moÅ¼na byÅ‚o wywoÅ‚ywaÄ‡ jÄ… w taki sposÃ³b. Typ zwracany przez funkcjÄ™ <code>to</code> to <code>Pair</code>, czyli para obiektÃ³w:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> wpis: Pair&lt;String, String&gt; = <span style="color:#e6db74">&#34;pies&#34;</span> to <span style="color:#e6db74">&#34;dog&#34;</span>
</span></span></code></pre></div><p><code>Map</code> podobnie jak <code>List</code> jest &ldquo;niemutowalna&rdquo;, czyli po jej utworzeniu nie moÅ¼na zmieniaÄ‡ jej zawartoÅ›ci. Istnieje teÅ¼ coÅ› takiego jak <code>MutableMap</code>, czyli &ldquo;mutowalny&rdquo; odpowiednik naszej <code>Mapy</code>, ktÃ³ry moÅ¼na utworzyÄ‡ za pomocÄ… funkcji <code>mutableMapOf</code>.</p>
<p>Wyszukiwanie wartoÅ›ci w <code>Map</code>ie odbywa siÄ™ za pomocÄ… operatora <code>[]</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> sÅ‚ownik = mapOf&lt;String, String&gt;(<span style="color:#75715e">/* wpisy */</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> polskiWyraz: String = readln()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> angielskiWyraz: String? = sÅ‚ownik[polskiWyraz]
</span></span></code></pre></div><p>ZauwaÅ¼cie, Å¼e wynik wyszukiwania jest typem opcjonalnym (z <code>?</code> doklejonym do typu przechowywanego w <code>Map</code>ie): nie moÅ¼emy przecieÅ¼ zagwarantowaÄ‡, Å¼e wpis z podanym przez nas kluczem bÄ™dzie znajdowaÄ‡ siÄ™ w naszej <code>Map</code>ie. PamiÄ™tajcie o tym przypadku, gdy bÄ™dziecie korzystaÄ‡ z tej struktury danych!</p>
<h1 id="co-dalej">Co dalej?</h1>
<p>Poznane dzisiaj narzÄ™dzia pozwolÄ… nam w sensowny sposÃ³b napisaÄ‡ kolejny duÅ¼y program: grÄ™ &ldquo;Bitwa Morska&rdquo;, czyli znanÄ… wam z wersji papierowej grÄ™ &ldquo;w statki&rdquo;. BÄ™dziemy siÄ™ tym zajmowaÄ‡ na nastÄ™pnych zajÄ™ciach (i prawdopodobnie nie skoÅ„czymy â€“ spodziewam siÄ™, Å¼e na losowanie pozycji statkÃ³w bÄ™dziemy potrzebowaÄ‡ kolejnych caÅ‚ych zajÄ™Ä‡).</p>
<p>Zgodnie odrzuciliÅ›cie propozycjÄ™ rozwiÄ…zywania zagadek programistycznych. Bajtazar z Bajtocji bÄ™dzie musiaÅ‚ znaleÅºÄ‡ innych pomocnikÃ³w, a my skupimy siÄ™ na pisaniu kolejnych gier. Po &ldquo;Bitwie Morskiej&rdquo; weÅºmiemy na warsztat klon &ldquo;Wordle&rdquo;, &ldquo;Sapera&rdquo; i napiszemy kilka prostych animacji.</p>
<p>MyÅ›lÄ™, Å¼e dobrze byÅ‚oby teÅ¼ wrÃ³ciÄ‡ do wczeÅ›niej napisanych programÃ³w i sprÃ³bowaÄ‡ uÅ¼yÄ‡ nowych rzeczy:</p>
<ul>
<li>W programie &ldquo;KÃ³Å‚ko i KrzyÅ¼yk&rdquo; zamiast typu <code>String</code> moÅ¼na uÅ¼yÄ‡ <code>enum class</code>. BÄ™dziemy potrzebowaÄ‡ dwÃ³ch typÃ³w: jednego do reprezentowania symbolu (kÃ³Å‚ko lub krzyÅ¼yk), drugiego do wyniku (wygrana X, wygrana O, remis).</li>
<li>SprÃ³bujcie przechowywaÄ‡ planszÄ™ w grze &ldquo;KÃ³Å‚ko i KrzyÅ¼yk&rdquo; jako <code>MutableMap&lt;â€¦&gt;</code> zamiast <code>MutableList&lt;â€¦&gt;</code></li>
<li>Nasza struktura danych w &ldquo;Wisielcu&rdquo; byÅ‚a nieco koÅ›lawa. MoÅ¼na jÄ… trochÄ™ naprostowaÄ‡ uÅ¼ywajÄ…c <code>data class Literka(val char: Char, var odkryta: Boolean)</code> (zauwaÅ¼cie, Å¼e <code>odkryta</code> to zmienna!).</li>
</ul>

</main>

  <footer>
  
  
  </footer>
  </body>
</html>

